/*
 * @lc app=leetcode.cn id=32 lang=cpp
 *
 * [32] 最长有效括号
 */

// @lc code=start
class Solution { 
public:
    int longestValidParentheses(string s) {
        int longest = 0;
        bool isValid = false;
        if (s.size() == 0 || s.size() == 1) return false;
        for (int i = 0; i < s.size() - 1; i++) {
            for (int j = i + 1; j < s.size(); j++) {
                bool currentValid = isValidPar(s.substr(i, j - i + 1));
                if (currentValid == true) {
                    longest = (longest >= (j - i + 1)) ? longest : (j - i + 1);
                    isValid = true;
                }
            }
        }
        return longest;
    }

    bool isValidPar(string s) {
        bool result = true;
        stack<char> pairs;
        for (int i = 0; i < s.length(); i++) {
            if(pairs.empty()) {
                pairs.push(s[i]);
                continue;
            }
            switch (s[i]) {
            case ')':
                result = (pairs.top() == '(');
                pairs.pop();
                break;
            default:
                pairs.push(s[i]);
                break;
            } // switch end
        if  (result == false) break;
        } // for end
        if (!pairs.empty()) result = false;
        return result;
    }
};
// @lc code=end


/**
 * @brief 超时
 * "((())())(()))(()()(()(()))(()((((()))))))((()())()))()()(()(((((()()()())))()())(()()))((((((())))((()))()()))))(()))())))()))()())((()()))))(()(((((())))))()((()(()(())((((())(())((()()(()())))())(()(())()()))())(()()()))()(((()())(((()()())))(((()()()))(()()))()))()))))))())()()((()(())(()))()((()()()((())))()(((()())(()))())())))(((()))))())))()(())))()())))())()((()))((()))()))(((())((()()()(()((()((())))((()()))())(()()(()))))())((())))(()))()))))))()(()))())(()())))))(()))((())(()((())(((((()()()(()()())))(()())()((()(()()))(()(())((()((()))))))))(()(())()())()(()(()(()))()()()(()()())))(())(()((((()()))())))(())((()(())())))))())()()))(((())))())((()(()))(()()))((())(())))))(()(()((()((()()))))))(()()()(()()()(()(())()))()))(((()(())()())(()))())))(((()))())(()((()))(()((()()()(())()(()())()(())(()(()((((())()))(((()()(((()())(()()()(())()())())(()(()()((()))))()(()))))(((())))()()))(()))((()))))()()))))((((()(())()()()((()))((()))())())(()((()()())))))))()))(((()))))))(()())))(((()))((()))())))(((()(((())))())(()))))(((()(((((((((((((())(((()))((((())())()))())((((())(((())))())(((()))))()())()(())())(()))))()))()()()))(((((())()()((()))())(()))()()(()()))(())(()()))()))))(((())))))((()()(()()()()((())((((())())))))((((((()((()((())())(()((()))(()())())())(()(())(())(()((())((())))(())())))(()()())((((()))))((()(())(()(()())))))))))((()())()()))((()(((()((()))(((((()()()()()(()(()((()(()))(()(()((()()))))()(()()((((((()((()())()))((())()()(((((()(()))))()()((()())((()())()(())((()))()()(()))"
 * Expected Answer: 168
 */

/**
 * @brief 巧妙解法，遍历两遍
 * 由左至右: 1.')'數量 > '('數量時，一定無效，數量歸零，繼續計算；2.若')'數量 = '('數量時，當前有效； 
 * 若最後 ')'數量 < '('數量，表示無法確定有效括弧，只能確定<=')'數量。故需倒序再驗證一次。
 * 由右至左: 1.')'數量 < '('數量時，一定無效，數量歸零，繼續計算；2.若')'數量 = '('數量時，當前有效；
 */